// Inicializaci√≥n y disponibilidad global de funciones cr√≠ticas
// Debemos asegurar que estas funciones est√©n disponibles para auth.js
(function initializeGlobalFunctions() {
  console.log('Inicializando funciones globales en scripts.js');
  
  // Detectar si es un dispositivo m√≥vil
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  window.isMobileDevice = isMobile;
  console.log(`Tipo de dispositivo detectado: ${isMobile ? 'M√≥vil' : 'Desktop'}`);
  
  // Verificar si hay un par√°metro de forzado de actualizaci√≥n en la URL
  const urlParams = new URLSearchParams(window.location.search);
  const forceRefresh = urlParams.get('force_refresh');
  
  if (forceRefresh === 'true') {
    console.log('Forzando actualizaci√≥n por par√°metro URL');
    // Limpiar todo el localStorage para una actualizaci√≥n completa
    localStorage.clear();
    // Recargar sin el par√°metro para evitar bucles
    window.location.href = window.location.pathname;
    return;
  }
  
  // Forzar limpieza de todos los tokens en cach√©
  // Esto asegura que se usen los tokens actualizados en KNOWN_TOKENS
  setTimeout(() => {
    if (typeof clearAllTokenCache === 'function') {
      console.log('Forzando limpieza de todos los tokens en cach√© debido a actualizaci√≥n masiva');
      clearAllTokenCache();
      localStorage.setItem('tokens_version', TOKENS_VERSION.toString());
      console.log(`Versi√≥n de tokens actualizada a: ${TOKENS_VERSION}`);
      
      // Limpieza adicional para dispositivos m√≥viles
      if (isMobile) {
        console.log('Realizando limpieza adicional para dispositivo m√≥vil');
        try {
          // Eliminar todas las claves relacionadas con tokens
          Object.keys(localStorage).forEach(key => {
            if (key.includes('token') || key.includes('Token')) {
              localStorage.removeItem(key);
            }
          });
          
          // Establecer marca de tiempo de √∫ltima limpieza
          localStorage.setItem('last_mobile_cleanup', Date.now().toString());
          console.log('Limpieza para m√≥vil completada');
        } catch (error) {
          console.error('Error durante limpieza para m√≥vil:', error);
        }
      }
    }
  }, 500);
  
  // Preparar objeto global en caso de que a√∫n no se hayan definido las funciones
  window.tvApp = window.tvApp || {};
  
  
  // Versi√≥n simplificada de loadChannel para asegurar que siempre hay algo disponible
  if (typeof window.loadChannel !== 'function') {
    window.loadChannel = function simplifiedLoadChannel(name) {
      console.log('Usando versi√≥n simplificada de loadChannel para:', name);
      const player = document.getElementById('player');
      const title = document.getElementById('channel-title');
      
      if (title) title.textContent = name;
      
      // Intentar reproducir canales de demo conocidos
      if (name === 'NASA TV Public') {
        if (player) {
          player.src = 'https://ntv1.akamaized.net/hls/live/2014075/NASA-NTV1-HLS/master.m3u8';
          player.load();
          player.play().catch(e => console.error('Error al reproducir NASA TV:', e));
        }
      } else if (name === 'Red Bull TV') {
        if (player) {
          player.src = 'https://rbmn-live.akamaized.net/hls/live/590964/BoRB-AT/master.m3u8';
          player.load();
          player.play().catch(e => console.error('Error al reproducir Red Bull TV:', e));
        }
      } else {
        // Para otros canales, solo actualizar la interfaz
        const playerContainer = document.querySelector('.video-player');
        if (playerContainer) {
          // Mostrar mensaje
          const infoMsg = document.createElement('div');
          infoMsg.className = 'welcome-message';
          infoMsg.innerHTML = `
            <h3>Canal seleccionado: ${name}</h3>
            <p>Este canal requiere la versi√≥n completa del reproductor.</p>
          `;
          
          // Limpiar contenedor y a√±adir mensaje
          const existingMsgs = playerContainer.querySelectorAll('.welcome-message');
          existingMsgs.forEach(el => el.remove());
          playerContainer.appendChild(infoMsg);
        }
      }
      
      return true;
    };
    
    console.log('Versi√≥n simplificada de loadChannel instalada como fallback');
  }
})();

// Esta funci√≥n ahora est√° definida al principio del archivo para evitar errores de referencia
function removeDashWarningMessage() {
  // Buscar cualquier mensaje de advertencia relacionado con DASH
  const allElements = document.querySelectorAll('div');
  allElements.forEach(el => {
    if (el.textContent && 
        (el.textContent.includes('formato DASH') || 
         el.textContent.includes('requiere un reproductor diferente') ||
         el.textContent.includes('DASH detectado'))) {
      console.log('Eliminando mensaje de advertencia DASH:', el.textContent);
      el.remove();
    }
  });
}

// Funciones de UI para mensajes y notificaciones
// Funci√≥n para mostrar un mensaje de bienvenida
function showWelcomeMessage() {
  // Verificar si existe el elemento para el mensaje de bienvenida
  let welcomeMsg = document.getElementById('welcome-msg');
  if (!welcomeMsg) {
    welcomeMsg = document.createElement('div');
    welcomeMsg.id = 'welcome-msg';
    welcomeMsg.className = 'welcome-message';
    
    // Contenido adaptado seg√∫n si es m√≥vil o desktop
    const mobileClass = window.isMobileDevice ? 'mobile-view' : '';
    welcomeMsg.innerHTML = `
      <h3>¬°Bienvenido al Reproductor de Canales!</h3>
      <p>Selecciona un canal desde la lista para comenzar a ver.</p>
      <p class="${mobileClass}">Recomendamos empezar con los canales de <span class="highlight">NASA TV Public</span> o <span class="highlight">Red Bull TV</span> que suelen funcionar mejor.</p>
      <p class="update-note ${mobileClass}">Los tokens de todos los canales han sido actualizados (${new Date().toLocaleString()}).</p>
      <div class="action-buttons">
        <button id="clear-cache-btn" class="action-button refresh-button">üîÑ Actualizar Tokens</button>
        ${window.isMobileDevice ? '<p class="mobile-note">Usa este bot√≥n si los canales no funcionan correctamente</p>' : ''}
      </div>
    `;
    
    // A√±adir el mensaje al contenedor del reproductor
    const playerContainer = document.querySelector('.video-player');
    if (playerContainer) {
      playerContainer.appendChild(welcomeMsg);
      
      // Agregar funcionalidad al bot√≥n de limpieza de cach√©
      document.getElementById('clear-cache-btn').addEventListener('click', function() {
        this.disabled = true;
        this.textContent = '‚è≥ Actualizando...';
        
        // Limpiar cach√© y recargar
        clearAllTokenCache();
        StorageSystem.setItem('tokens_version', TOKENS_VERSION.toString());
        StorageSystem.setItem('last_mobile_cleanup', Date.now().toString());
        
        showStatus('Tokens actualizados. Recargando p√°gina...');
        
        // Retrasar la recarga para que el usuario vea el mensaje
        setTimeout(() => {
          window.location.href = window.location.pathname + '?force_refresh=true';
        }, 1500);
      });
    }
  }
  
  welcomeMsg.style.display = 'block';
}

// Funci√≥n para mostrar mensaje de prueba de canales de demostraci√≥n
function showTryDemoChannelsMessage() {
  // Verificar si existe el elemento para el mensaje
  let demoMsg = document.getElementById('try-demo-msg');
  if (!demoMsg) {
    demoMsg = document.createElement('div');
    demoMsg.id = 'try-demo-msg';
    demoMsg.className = 'demo-message';
    demoMsg.innerHTML = `
      <h3>Canal no disponible</h3>
      <p>Este canal no est√° disponible en este momento o requiere permisos especiales.</p>
      <p>Prueba con los canales de demostraci√≥n como <span class="highlight">NASA TV Public</span> o <span class="highlight">Red Bull TV</span>.</p>
      <button id="try-demo-btn" class="action-button">Ver canal de demostraci√≥n</button>
    `;
    
    // A√±adir el mensaje al contenedor del reproductor
    const playerContainer = document.querySelector('.video-player');
    if (playerContainer) {
      playerContainer.appendChild(demoMsg);
    }
    
    // Agregar evento al bot√≥n
    setTimeout(() => {
      const tryDemoBtn = document.getElementById('try-demo-btn');
      if (tryDemoBtn) {
        tryDemoBtn.addEventListener('click', () => {
          const demoChannels = document.querySelectorAll('#channel-list li.demo-channel');
          if (demoChannels.length > 0) {
            demoChannels[0].click();
          }
        });
      }
    }, 100);
  }
  
  demoMsg.style.display = 'block';
}

// Funci√≥n para mostrar un mensaje espec√≠fico para streams bloqueados
function showBlockedStreamMessage(channelName) {
  // Verificar si existe el elemento para el mensaje
  let blockedMsg = document.getElementById('blocked-stream-msg');
  if (!blockedMsg) {
    blockedMsg = document.createElement('div');
    blockedMsg.id = 'blocked-stream-msg';
    blockedMsg.className = 'blocked-message';
    blockedMsg.innerHTML = `
      <h3>Canal con restricciones</h3>
      <p>El stream para <strong>${channelName}</strong> no est√° disponible debido a una de estas razones:</p>
      <ul>
        <li>El token de acceso ha expirado</li>
        <li>El servidor bloquea el acceso desde nuestra p√°gina</li>
        <li>Hay restricciones geogr√°ficas para este contenido</li>
      </ul>
      <p>Puedes intentar buscar en RojaDirecta o probar con un canal de demostraci√≥n.</p>
      <div class="blocked-actions">
        <button id="try-rojadirecta-btn" class="action-button rojadirecta-button">Buscar en RojaDirecta</button>
        <button id="try-demo-blocked-btn" class="action-button">Ver canal de demostraci√≥n</button>
      </div>
    `;
    
    // A√±adir el mensaje al contenedor del reproductor
    const playerContainer = document.querySelector('.video-player');
    if (playerContainer) {
      playerContainer.appendChild(blockedMsg);
    }
    
    // Agregar eventos a los botones
    setTimeout(() => {
      const tryDemoBtn = document.getElementById('try-demo-blocked-btn');
      if (tryDemoBtn) {
        tryDemoBtn.addEventListener('click', () => {
          const demoChannels = document.querySelectorAll('#channel-list li.demo-channel');
          if (demoChannels.length > 0) {
            demoChannels[0].click();
          }
        });
      }
      
      const tryRojaBtn = document.getElementById('try-rojadirecta-btn');
      if (tryRojaBtn) {
        tryRojaBtn.addEventListener('click', async () => {
          tryRojaBtn.disabled = true;
          tryRojaBtn.textContent = 'Buscando...';
          
          try {
            showStatus(`Buscando ${channelName} en RojaDirecta...`);
            const url = await getFromRojaDirecta(channelName);
            
            if (url) {
              console.log(`Stream encontrado en RojaDirecta: ${url.substring(0, 50)}...`);
              blockedMsg.style.display = 'none';
              
              // Agregar la URL a la lista de fuentes del canal
              if (!CHANNELS[channelName]) CHANNELS[channelName] = [];
              CHANNELS[channelName].push(url);
              sourceIndex = CHANNELS[channelName].length - 1;
              
              // Reproducir el stream
              attachStream(url);
            } else {
              showStatus(`No se encontr√≥ stream en RojaDirecta para ${channelName}`);
              tryRojaBtn.disabled = false;
              tryRojaBtn.textContent = 'Intentar de nuevo';
            }
          } catch (error) {
            console.error(`Error buscando en RojaDirecta: ${error.message}`);
            showStatus(`Error buscando en RojaDirecta: ${error.message}`);
            tryRojaBtn.disabled = false;
            tryRojaBtn.textContent = 'Intentar de nuevo';
          }
        });
      }
    }, 100);
  } else {
    // Actualizar el nombre del canal en el mensaje existente
    const channelNameEl = blockedMsg.querySelector('strong');
    if (channelNameEl) {
      channelNameEl.textContent = channelName;
    }
  }
  
  blockedMsg.style.display = 'block';
}

// Funci√≥n para mostrar un bot√≥n de "Intentar otro canal"
function showTryAnotherButton() {
  const playerContainer = document.querySelector('.video-player');
  if (!playerContainer) return;
  
  // Eliminar botones existentes
  const existingBtn = document.getElementById('try-another-btn');
  if (existingBtn) existingBtn.remove();
  
  const tryBtn = document.createElement('button');
  tryBtn.id = 'try-another-btn';
  tryBtn.className = 'action-button try-another';
  tryBtn.textContent = 'Intentar con otro canal';
  tryBtn.addEventListener('click', () => {
    const demoChannels = document.querySelectorAll('#channel-list li.demo-channel');
    if (demoChannels.length > 0) {
      demoChannels[0].click();
    }
  });
  
  playerContainer.appendChild(tryBtn);
}

// Funci√≥n para a√±adir un bot√≥n de play cuando autoplay est√° bloqueado
function addPlayButton() {
  const playerContainer = document.querySelector('.video-player');
  if (!playerContainer) return;
  
  // Eliminar botones existentes
  const existingBtn = document.getElementById('manual-play-btn');
  if (existingBtn) existingBtn.remove();
  
  const playBtn = document.createElement('button');
  playBtn.id = 'manual-play-btn';
  playBtn.className = 'action-button play-button';
  playBtn.innerHTML = '‚ñ∂Ô∏è Reproducir';
  playBtn.addEventListener('click', () => {
    const video = document.getElementById('player');
    if (video) {
      video.play().catch(err => {
        console.error('Error al intentar reproducir manualmente:', err);
      });
      playBtn.style.display = 'none';
    }
  });
  
  playerContainer.appendChild(playBtn);
}

// Funciones de cach√© de tokens para optimizar las solicitudes y reducir carga en el servidor
// -----------------------------
// Estas funciones manejan el almacenamiento y recuperaci√≥n de tokens en localStorage
// para evitar solicitudes innecesarias al backend

// Sistema avanzado de almacenamiento con respaldo
// Implementa m√∫ltiples mecanismos de almacenamiento para garantizar compatibilidad entre dispositivos
const StorageSystem = {
  // Verifica si localStorage est√° disponible y funciona correctamente
  isLocalStorageAvailable: function() {
    try {
      const test = '__storage_test__';
      localStorage.setItem(test, test);
      const result = localStorage.getItem(test) === test;
      localStorage.removeItem(test);
      return result;
    } catch (e) {
      return false;
    }
  },
  
  // Verifica si sessionStorage est√° disponible
  isSessionStorageAvailable: function() {
    try {
      const test = '__storage_test__';
      sessionStorage.setItem(test, test);
      const result = sessionStorage.getItem(test) === test;
      sessionStorage.removeItem(test);
      return result;
    } catch (e) {
      return false;
    }
  },
  
  // Almacenamiento en memoria como √∫ltimo recurso
  memoryStorage: {},
  
  // Guarda un valor utilizando el mejor m√©todo disponible
  setItem: function(key, value) {
    try {
      if (this.isLocalStorageAvailable()) {
        localStorage.setItem(key, value);
        return true;
      } else if (this.isSessionStorageAvailable()) {
        console.warn('Usando sessionStorage como respaldo (se perder√° al cerrar pesta√±a)');
        sessionStorage.setItem(key, value);
        return true;
      } else {
        console.warn('Usando almacenamiento en memoria (se perder√° al recargar)');
        this.memoryStorage[key] = value;
        return true;
      }
    } catch (error) {
      console.error('Error al guardar datos:', error);
      // √öltimo intento: guardar en memoria
      try {
        this.memoryStorage[key] = value;
        return true;
      } catch (e) {
        return false;
      }
    }
  },
  
  // Obtiene un valor utilizando el mejor m√©todo disponible
  getItem: function(key) {
    try {
      if (this.isLocalStorageAvailable() && localStorage.getItem(key) !== null) {
        return localStorage.getItem(key);
      } else if (this.isSessionStorageAvailable() && sessionStorage.getItem(key) !== null) {
        return sessionStorage.getItem(key);
      } else if (key in this.memoryStorage) {
        return this.memoryStorage[key];
      }
      return null;
    } catch (error) {
      console.error('Error al recuperar datos:', error);
      // Intento de respaldo en memoria
      if (key in this.memoryStorage) {
        return this.memoryStorage[key];
      }
      return null;
    }
  },
  
  // Elimina un valor de todos los almacenamientos
  removeItem: function(key) {
    try {
      if (this.isLocalStorageAvailable()) {
        localStorage.removeItem(key);
      }
      if (this.isSessionStorageAvailable()) {
        sessionStorage.removeItem(key);
      }
      delete this.memoryStorage[key];
      return true;
    } catch (error) {
      console.error('Error al eliminar datos:', error);
      return false;
    }
  },
  
  // Limpia todo el almacenamiento
  clear: function() {
    try {
      if (this.isLocalStorageAvailable()) {
        localStorage.clear();
      }
      if (this.isSessionStorageAvailable()) {
        sessionStorage.clear();
      }
      this.memoryStorage = {};
      return true;
    } catch (error) {
      console.error('Error al limpiar almacenamiento:', error);
      return false;
    }
  }
};

// Funci√≥n para obtener un token v√°lido desde la cach√©
function getValidCachedToken(channelName) {
  try {
    // Verificar versi√≥n del token
    const savedTokensVersion = StorageSystem.getItem('tokens_version');
    
    // Si la versi√≥n ha cambiado, invalidar todas las cach√©s de tokens
    if (!savedTokensVersion || parseInt(savedTokensVersion) < TOKENS_VERSION) {
      console.log(`Versi√≥n de tokens actualizada: ${savedTokensVersion || 'ninguna'} -> ${TOKENS_VERSION}. Limpiando cach√© de tokens.`);
      clearAllTokenCache();
      StorageSystem.setItem('tokens_version', TOKENS_VERSION.toString());
      return null;
    }
    
    // Dispositivos m√≥viles: verificar si ha pasado m√°s de 30 minutos desde la √∫ltima limpieza
    if (window.isMobileDevice) {
      const lastCleanup = StorageSystem.getItem('last_mobile_cleanup');
      if (lastCleanup) {
        const elapsed = Date.now() - parseInt(lastCleanup);
        // 30 minutos = 1800000 ms
        if (elapsed > 1800000) {
          console.log('Han pasado m√°s de 30 minutos desde la √∫ltima limpieza en m√≥vil. Renovando tokens...');
          clearAllTokenCache();
          StorageSystem.setItem('last_mobile_cleanup', Date.now().toString());
          return null;
        }
      }
    }
    
    // Obtener el token almacenado para el canal
    const cacheKey = `token_${channelName.replace(/\s+/g, '_').toLowerCase()}`;
    const cachedData = StorageSystem.getItem(cacheKey);
    
    if (!cachedData) {
      console.log(`No hay token en cach√© para ${channelName}`);
      return null;
    }
    
    const tokenData = JSON.parse(cachedData);
    
    // Verificar si el token ha expirado (considerando un margen de seguridad de 5 minutos)
    const now = Date.now();
    const safetyMargin = 5 * 60 * 1000; // 5 minutos en milisegundos
    
    // Para dispositivos m√≥viles, usamos un margen de seguridad mayor (15 minutos)
    const mobileSafetyMargin = 15 * 60 * 1000;
    const actualMargin = window.isMobileDevice ? mobileSafetyMargin : safetyMargin;
    
    if (tokenData.expiresAt && (tokenData.expiresAt - actualMargin) > now) {
      console.log(`Usando token en cach√© para ${channelName} (v√°lido por ${Math.floor((tokenData.expiresAt - now) / 60000)} minutos m√°s)`);
      return tokenData.token;
    } else {
      console.log(`Token en cach√© para ${channelName} ha expirado o est√° por expirar`);
      StorageSystem.removeItem(cacheKey);
      return null;
    }
  } catch (error) {
    console.error(`Error al obtener token en cach√© para ${channelName}:`, error);
    return null;
  }
}

// Funci√≥n para limpiar token espec√≠fico de la cach√©
function clearTokenCache(channelName) {
  try {
    const cacheKey = `token_${channelName.replace(/\s+/g, '_').toLowerCase()}`;
    StorageSystem.removeItem(cacheKey);
    console.log(`Token en cach√© para ${channelName} eliminado`);
    return true;
  } catch (error) {
    console.error(`Error al limpiar token en cach√© para ${channelName}:`, error);
    return false;
  }
}

// Funci√≥n para limpiar todos los tokens en cach√©
function clearAllTokenCache() {
  try {
    // Buscar todas las claves que empiezan con token_ en localStorage
    if (StorageSystem.isLocalStorageAvailable()) {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('token_')) {
          const channelName = key.replace('token_', '').replace(/_/g, ' ');
          console.log(`Eliminando token en cach√© para ${channelName}`);
          localStorage.removeItem(key);
        }
      }
    }
    
    // Buscar todas las claves que empiezan con token_ en sessionStorage
    if (StorageSystem.isSessionStorageAvailable()) {
      for (let i = 0; i < sessionStorage.length; i++) {
        const key = sessionStorage.key(i);
        if (key && key.startsWith('token_')) {
          sessionStorage.removeItem(key);
        }
      }
    }
    
    // Limpiar memoria
    Object.keys(StorageSystem.memoryStorage).forEach(key => {
      if (key.startsWith('token_')) {
        delete StorageSystem.memoryStorage[key];
      }
    });
    
    console.log('Cach√© de tokens limpiada correctamente');
    return true;
  } catch (error) {
    console.error('Error al limpiar cach√© de tokens:', error);
    return false;
  }
}

// Funci√≥n para guardar un token en cach√©
function cacheToken(channelName, token, ttlMinutes = 60, tokenType = null) {
  try {
    // No almacenar tokens vac√≠os o inv√°lidos
    if (!token || token.length < 10) {
      console.warn(`Token inv√°lido para ${channelName}, no se guardar√° en cach√©`);
      return false;
    }
    
    // Si no se especific√≥ tipo, usar el tipo de dispositivo actual
    if (!tokenType) {
      tokenType = window.isMobileDevice ? 'mobile' : 'desktop';
    }
    
    // Usar clave espec√≠fica seg√∫n el tipo de token
    const cacheKey = `token_${channelName.replace(/\s+/g, '_').toLowerCase()}_${tokenType}`;
    const now = Date.now();
    const expiresAt = now + (ttlMinutes * 60 * 1000);
    
    const tokenData = {
      token: token,
      timestamp: now,
      expiresAt: expiresAt,
      channel: channelName,
      device: tokenType,
      userAgent: navigator.userAgent.substring(0, 100) // Guardar parte del UA para diagn√≥stico
    };
    
    StorageSystem.setItem(cacheKey, JSON.stringify(tokenData));
    console.log(`Token para ${channelName} (${tokenType}) guardado en cach√© (expira en ${ttlMinutes} minutos)`);
    
    return true;
  } catch (error) {
    console.error(`Error al guardar token en cach√© para ${channelName}:`, error);
    return false;
  }
}

// Funci√≥n para extraer un token de una URL
function extractTokenFromUrl(url) {
  if (!url) return null;
  
  // Patrones comunes de tokens en URLs
  const patterns = [
    /token=([^&]+)/,  // Formato est√°ndar: token=abc123
    /hdnts=([^&]+)/,  // Formato Akamai: hdnts=abc123
    /auth=([^&]+)/,   // Formato auth: auth=abc123
    /wmsAuthSign=([^&]+)/  // Formato wmsAuthSign: wmsAuthSign=abc123
  ];
  
  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match && match[1]) {
      return match[1];
    }
  }
  
  return null;
}

// Funci√≥n para estimar el tiempo de expiraci√≥n de un token basado en su formato
function estimateTokenExpiration(token) {
  if (!token) return 60; // Valor predeterminado: 60 minutos
  
  // Buscar timestamps Unix en el token (10 d√≠gitos)
  const timestampMatch = token.match(/\d{10}/);
  if (timestampMatch) {
    const timestamp = parseInt(timestampMatch[0]) * 1000; // Convertir a milisegundos
    const now = Date.now();
    
    // Si el timestamp est√° en el futuro, probablemente sea una fecha de expiraci√≥n
    if (timestamp > now) {
      const minutesUntilExpiration = Math.floor((timestamp - now) / 60000);
      // Limitar a un m√°ximo razonable (3 horas)
      return Math.min(minutesUntilExpiration, 180);
    }
  }
  
  // Para tokens KNOWN_TOKENS, usar un tiempo de vida m√°s largo (2 horas)
  // ya que normalmente son actualizados manualmente
  if (token.length > 40) {
    return 120;
  }
  
  // Valor predeterminado para otros formatos de token
  return 60;
}

// Constantes para la URL base de los diferentes canales
const CHANNEL_BASE_URLS = {
  "Liga 1 Max": "https://bGFuZQ.fubohd.com/liga1max/mono.m3u8",
  "DIRECTV Sports HD": "https://tyg2mnl9.fubohd.com/dsports/mono.m3u8",
  "DIRECTV Sports 2 HD": "https://anvtcax.fubohd.com/dsports2/mono.m3u8",
  "DirecTV Plus": "https://eWVz.fubohd.com/dsportsplus/mono.m3u8",
  "ESPN": "https://am91cm5leQ.fubohd.com/espn/mono.m3u8",
  "ESPN2": "https://rm8zcvk3.fubohd.com/espn2/mono.m3u8",
  "ESPN3": "https://eWVz.fubohd.com/espn3/mono.m3u8",
  "ESPN4": "https://aGl2ZQ.fubohd.com/espn4/mono.m3u8",
  "ESPN5": "https://qzv4jmsc.fubohd.com/espn5/mono.m3u8",
  "ESPN6": "https://c2nvdxq.fubohd.com/espn6/mono.m3u8",
  "ESPN7": "https://c2nvdxq.fubohd.com/espn7/mono.m3u8",
  "ESPN Premium": "https://bmf0aw9u.fubohd.com/espnpremium/mono.m3u8"
};

// scripts.js mejorado
// -----------------------------
// Configuraci√≥n de canales: llena manualmente arrays o d√©jalos vac√≠os y se intentar√°
// buscar la primera fuente disponible usando la base p√∫blica de iptv-org.
// URL de la lista M3U externa proporcionada por el usuario
// Se eliminan playlists externas; usamos backend para canales espec√≠ficos
const PLAYLIST_URLS = []; // dejado vac√≠o por si se quiere volver a usar

// URLs de demostraci√≥n que funcionan en producci√≥n - Usar s√≥lo para pruebas
const DEMO_STREAMS = {
  "Ejemplo 1": "https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8", // Stream de prueba 1080p
  "NASA TV": "https://ntv1.akamaized.net/hls/live/2014075/NASA-NTV1-HLS/master.m3u8", // NASA TV p√∫blica
  "Red Bull TV": "https://rbmn-live.akamaized.net/hls/live/590964/BoRB-AT/master.m3u8", // Red Bull TV
  "Demo HLS": "https://cph-p2p-msl.akamaized.net/hls/live/2000341/test/master.m3u8", // Stream HLS con buena compatibilidad
  "Demo Bajo": "https://bitdash-a.akamaihd.net/content/MI201109210084_1/m3u8s/f08e80da-bf1d-4e3d-8899-f0f6155f6efa.m3u8" // Stream de baja calidad que suele funcionar bien
};

// Versi√≥n de tokens - incrementar cuando se actualicen tokens importantes
const TOKENS_VERSION = 4; // Actualizado para el soporte m√≥vil

// Tokens conocidos para canales espec√≠ficos (se actualizan manualmente)
const KNOWN_TOKENS = {
  "Liga 1 Max": "d38e5213144afeaf29de7d39109cd37162b57c3b-65-1750446275-1750428275",
  "DIRECTV Sports HD": "61cfa088b097200767adf86d505b4b9378c0cbc2-5-1750443916-1750425916",
  "DIRECTV Sports 2 HD": "ec806f16b0201dfd2b8ea8d65e43b258c9eb5eaa-c3-1750445977-1750427977",
  "DirecTV Plus": "6be5b52b874cc027af845465a1066be6be940865-d7-1750446014-1750428014",
  
  "ESPN": "9b9586272b50bb1ac4c6be0278fdfdbe3994dccf-de-1750446061-1750428061",
  "ESPN2": "85cdc5ecd8f998f9013d805e252604e795366a5c-9f-1750446099-1750428099",
  "ESPN3": "66342a841c5d31582050612be72f4de456f29844-fd-1750446130-1750428130",
  "ESPN4": "657793ab65d0b60703472252f2d5c41d32d18a01-49-1750446153-1750428153",
  "ESPN5": "8b1eb3e50f60713d7d4a20897ae6479006423158-eb-1750446190-1750428190",
  "ESPN6": "bbe7a79233f58724968e3155c887c324cb8f08a1-a8-1750446215-1750428215",
  "ESPN7": "82c2692613f5260ab3a53c2a1a73ab3930b736bc-18-1750446248-1750428248",
  "ESPN Premium": "cf9d5acd892aef2408bed172229b8ad12b1e3784-85-1750446345-1750428345"
  // Movistar Deportes y Gol Per√∫ ser√°n a√±adidos cuando est√©n disponibles
};

// API base URL - cambia autom√°ticamente entre desarrollo y producci√≥n
const isLocalhost = window.location.hostname === 'localhost' || 
                   window.location.hostname === '127.0.0.1' || 
                   window.location.hostname === '';

// Forzar la URL espec√≠fica de Render en producci√≥n
const API_BASE_URL = isLocalhost 
  ? 'http://localhost:4000'
  : 'https://depechito.onrender.com';

console.log('==== CONFIGURACI√ìN DE LA APLICACI√ìN ====');
console.log('Host actual:', window.location.hostname);
console.log('Ambiente detectado:', isLocalhost ? 'Desarrollo local' : 'Producci√≥n');
console.log('API_BASE_URL:', API_BASE_URL);
console.log('====================================');

// Mapas de logos (URLs actualizadas para evitar errores 404)
const LOGOS = {
  "DIRECTV Sports HD": "https://i.ibb.co/vXbTGnW/DIRECTV-Sports-HD.png",
  "DIRECTV Sports 2 HD": "https://i.ibb.co/pX3zv1J/DIRECTV-Sports-2-HD.png", 
  "Movistar Deportes": "https://i.ibb.co/d6gHyyH/MovistarDeportes.png",
  "ESPN Premium": "https://i.ibb.co/C77tcRP/ESPNPremium.png",
  "ESPN": "https://i.ibb.co/ZKpddZQ/ESPN.png",
  "ESPN2": "https://i.ibb.co/wpLwTXr/ESPN2.png",
  "ESPN3": "https://i.ibb.co/L5w0Rf9/ESPN3.png",
  "ESPN4": "https://i.ibb.co/C6YBkNB/ESPN4.png",
  "ESPN5": "https://i.ibb.co/ZKpddZQ/ESPN.png", // Usando logo de ESPN como base
  "ESPN6": "https://i.ibb.co/ZKpddZQ/ESPN.png", // Usando logo de ESPN como base
  "ESPN7": "https://i.ibb.co/ZKpddZQ/ESPN.png", // Usando logo de ESPN como base
  "Liga 1 Max": "https://i.ibb.co/xJ37DbW/Liga1Max.png",
  "Gol Per√∫": "https://i.ibb.co/FnhznGr/GolPeru.png",
  "DirecTV Plus": "https://i.ibb.co/Z1h95KP/DIRECTVPlus.png"
};

const CHANNELS = {
  "DIRECTV Sports HD": [], // Dejamos vac√≠o para que use el token actualizado desde KNOWN_TOKENS
  "DIRECTV Sports 2 HD": [],
  "DirecTV Plus": [],
  "Movistar Deportes": [],
  "ESPN Premium": [],
  "ESPN": [],
  "ESPN2": [],
  "ESPN3": [],
  "ESPN4": [],
  "ESPN5": [],
  "ESPN6": [],
  "ESPN7": [],
  "Liga 1 Max": [],
  "Gol Per√∫": [],
  // Agregar canales de demostraci√≥n como canales regulares para f√°cil acceso
  "NASA TV Public": ["https://ntv1.akamaized.net/hls/live/2014075/NASA-NTV1-HLS/master.m3u8"],
  "Red Bull TV": ["https://rbmn-live.akamaized.net/hls/live/590964/BoRB-AT/master.m3u8"]
};

// ---- Utilidades para playlist M3U externa ----
async function fetchTextViaProxy(url) {
  const proxied = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(url);
  const res = await fetch(proxied);
  return res.text();
}

function parseM3U(m3uText) {
  const lines = m3uText.split(/\r?\n/);
  const results = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line.startsWith('#EXTINF')) {
      const nameMatch = line.split(',').pop().trim();
      const urlLine = lines[i + 1] || '';
      if (urlLine && urlLine.startsWith('http')) {
        results.push({ name: nameMatch, url: urlLine.trim() });
      }
    }
  }
  return results;
}

function mergeExternalChannels(list) {
  list.forEach(({ name, url }) => {
    if (!url.endsWith('.m3u8') && !url.endsWith('.ts')) return; // s√≥lo flujos √∫tiles
    if (!CHANNELS[name]) {
      CHANNELS[name] = [url];
    } else if (!CHANNELS[name].includes(url)) {
      CHANNELS[name].push(url);
    }
  });
}

// Cach√© para cat√°logos iptv-org
const IPTV_CACHE = { channels: null, streams: null };

async function fetchCatalog(url, key) {
  if (IPTV_CACHE[key]) return IPTV_CACHE[key];
  const res = await fetch('https://api.allorigins.win/raw?url=' + encodeURIComponent(url));
  const data = await res.json();
  IPTV_CACHE[key] = data;
  return data;
}

// Funci√≥n para obtener enlace para m√≥viles
async function fetchMobileLink(channelName) {
  console.log(`Intentando obtener enlace para M√ìVIL: ${channelName} desde ${API_BASE_URL}`);
  
  // Construir URL espec√≠fica para m√≥viles
  const url = `${API_BASE_URL}/api/mobile/stream?channel=${encodeURIComponent(channelName)}&device=${encodeURIComponent(navigator.userAgent)}`;
  
  try {
    // Intentar obtener stream espec√≠fico para m√≥viles
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'X-Requested-With': 'XMLHttpRequest',
        'X-Mobile-Device': 'true'
      }
    });
    
    if (!response.ok) {
      console.warn(`No se pudo obtener enlace para m√≥viles: ${response.status}`);
      // Fallback al m√©todo est√°ndar
      return fetchNewLink(channelName);
    }
    
    const data = await response.json();
    
    if (data && data.url) {
      console.log(`Enlace para m√≥viles obtenido para ${channelName}`);
      
      // Si hay token, guardarlo en cach√©
      const token = extractStreamToken(data.url);
      if (token) {
        console.log(`Token para m√≥viles encontrado y guardado: ${token.substring(0, 10)}...`);
        cacheToken(channelName, token, 60, 'mobile');
      }
      
      return data.url;
    } else {
      console.warn('No se obtuvo URL desde el endpoint para m√≥viles');
      // Fallback al m√©todo est√°ndar
      return fetchNewLink(channelName);
    }
  } catch (error) {
    console.error('Error al obtener enlace para m√≥viles:', error);
    // Fallback al m√©todo est√°ndar
    return fetchNewLink(channelName);
  }
}

async function fetchNewLink(channelName) {
  // Log para depuraci√≥n en producci√≥n
  console.log(`Intentando obtener enlace para: ${channelName} desde ${API_BASE_URL}`);
  
  // Verificar si tenemos un token en cach√© para el canal
  const cachedToken = getValidCachedToken(channelName);
  const lower = channelName.toLowerCase();
  
  // Si tenemos un token en cach√©, construir la URL correspondiente
  if (cachedToken && CHANNEL_BASE_URLS[channelName]) {
    console.log(`Usando token en cach√© para ${channelName}: ${cachedToken.substring(0, 10)}...`);
    return `${CHANNEL_BASE_URLS[channelName]}?token=${cachedToken}`;
  }
  
  // Usar los tokens conocidos en KNOWN_TOKENS cuando est√©n disponibles
  if (KNOWN_TOKENS[channelName]) {
    const token = KNOWN_TOKENS[channelName];
    console.log(`Usando token fijo para ${channelName}: ${token.substring(0, 10)}...`);
    
    // Estimar la duraci√≥n del token y guardarlo en cach√©
    const ttl = estimateTokenExpiration(token);
    cacheToken(channelName, token, ttl);
    
    // Usar siempre las URLs base actualizadas de CHANNEL_BASE_URLS
    if (CHANNEL_BASE_URLS[channelName]) {
      return `${CHANNEL_BASE_URLS[channelName]}?token=${token}`;
    }
    
    // URLs de respaldo espec√≠ficas seg√∫n el canal por si no est√° en CHANNEL_BASE_URLS
    if (lower.includes('liga 1 max')) {
      return `https://bGFuZQ.fubohd.com/liga1max/mono.m3u8?token=${token}`;
    } else if (lower.includes('directv sports 2') || lower.includes('dsports2')) {
      return `https://anvtcax.fubohd.com/dsports2/mono.m3u8?token=${token}`;
    } else if (lower.includes('directv sports') && !lower.includes('2') && !lower.includes('plus')) {
      return `https://tyg2mnl9.fubohd.com/dsports/mono.m3u8?token=${token}`;
    } else if (lower.includes('directv plus') || lower.includes('dsports plus')) {
      return `https://eWVz.fubohd.com/dsportsplus/mono.m3u8?token=${token}`;
    } else if (lower.includes('espn premium')) {
      return `https://bmf0aw9u.fubohd.com/espnpremium/mono.m3u8?token=${token}`;
    } else if (lower.includes('espn3') || lower.includes('espn 3')) {
      return `https://eWVz.fubohd.com/espn3/mono.m3u8?token=${token}`;
    } else if (lower.includes('espn2') || lower.includes('espn 2')) {
      return `https://rm8zcvk3.fubohd.com/espn2/mono.m3u8?token=${token}`;
    } else if (lower.includes('espn4') || lower.includes('espn 4')) {
      return `https://aGl2ZQ.fubohd.com/espn4/mono.m3u8?token=${token}`;
    } else if (lower.includes('espn5') || lower.includes('espn 5')) {
      return `https://qzv4jmsc.fubohd.com/espn5/mono.m3u8?token=${token}`;
    } else if (lower.includes('espn6') || lower.includes('espn 6')) {
      return `https://c2nvdxq.fubohd.com/espn6/mono.m3u8?token=${token}`;
    } else if (lower.includes('espn7') || lower.includes('espn 7')) {
      return `https://c2nvdxq.fubohd.com/espn7/mono.m3u8?token=${token}`;
    } else if (lower.includes('espn') && !lower.includes('premium') && !lower.includes('2') && !lower.includes('3') && 
               !lower.includes('4') && !lower.includes('5') && !lower.includes('6') && !lower.includes('7')) {
      return `https://am91cm5leQ.fubohd.com/espn/mono.m3u8?token=${token}`;
    }
  }
  
  // Intentar buscar en RojaDirecta si est√° habilitado
  try {
    const rojaUrl = await getFromRojaDirecta(channelName);
    if (rojaUrl) {
      console.log(`Usando stream de RojaDirecta para ${channelName}`);
      
      // Extraer y guardar el token si est√° disponible
      const extractedToken = extractTokenFromUrl(rojaUrl);
      if (extractedToken) {
        cacheToken(channelName, extractedToken);
      }
      
      return rojaUrl;
    }
  } catch (error) {
    console.warn(`Error buscando en RojaDirecta: ${error.message}`);
  }
  
  // Caso especial DirecTV Sports via scraper backend
  if (lower.includes('directv sports 2') || lower.includes('dsports2')) {
    if (KNOWN_TOKENS["DIRECTV Sports 2 HD"]) {
      const dsports2Token = KNOWN_TOKENS["DIRECTV Sports 2 HD"];
      // Guardar token en cach√©
      cacheToken("DIRECTV Sports 2 HD", dsports2Token);
      return `https://dglvz29s.fubohd.com/dsports2/mono.m3u8?token=${dsports2Token}`;
    }
    try {
      const res = await fetch(`${API_BASE_URL}/api/stream/dsports2`);
      const data = await res.json();
      
      // Extraer y guardar el token si est√° disponible
      if (data.url) {
        const extractedToken = extractTokenFromUrl(data.url);
        if (extractedToken) {
          cacheToken("DIRECTV Sports 2 HD", extractedToken);
        }
      }
      
      return data.url;
    } catch (e) {
      console.warn('Proxy dsports2 failed', e);
    }    } else if (lower.includes('espn premium')) {
      if (KNOWN_TOKENS["ESPN Premium"]) {
        const espnPremiumToken = KNOWN_TOKENS["ESPN Premium"];
        // Guardar token en cach√©
        cacheToken("ESPN Premium", espnPremiumToken);
        return `https://a2lja3m.fubohd.com/espnpremium/mono.m3u8?token=${espnPremiumToken}`;
      }
      try {
        const res = await fetch(`${API_BASE_URL}/api/stream/espnpremium`);
        const data = await res.json();
        
        // Extraer y guardar el token si est√° disponible
        if (data.url) {
          const extractedToken = extractTokenFromUrl(data.url);
          if (extractedToken) {
            cacheToken("ESPN Premium", extractedToken);
          }
        }
        
        return data.url;
      } catch (e) {
        console.warn('Proxy espnpremium failed', e);
      }} else if (lower.includes('espn4') || lower.includes('espn 4')) {
      if (KNOWN_TOKENS["ESPN4"]) {
        const espn4Token = KNOWN_TOKENS["ESPN4"];
        // Guardar token en cach√©
        cacheToken("ESPN4", espn4Token);
        return `https://dglvz29s.fubohd.com/espn4/mono.m3u8?token=${espn4Token}`;
      }
      try {
        const res = await fetch(`${API_BASE_URL}/api/stream/espn4`);
        const data = await res.json();
        
        // Extraer y guardar el token si est√° disponible
        if (data.url) {
          const extractedToken = extractTokenFromUrl(data.url);
          if (extractedToken) {
            cacheToken("ESPN4", extractedToken);
          }
        }
        
        console.log('Using URL for ESPN4:', data.url);
        return data.url;
      } catch (e) {
        console.warn('Proxy espn4 failed', e);
      }    } else if (lower.includes('espn5') || lower.includes('espn 5')) {
      if (KNOWN_TOKENS["ESPN5"]) {
        const espn5Token = KNOWN_TOKENS["ESPN5"];
        // Guardar token en cach√©
        cacheToken("ESPN5", espn5Token);
        return `https://qzv4jmsc.fubohd.com/espn5/mono.m3u8?token=${espn5Token}`;
      }
      try {
        const res = await fetch(`${API_BASE_URL}/api/stream/espn5`);
        const data = await res.json();
        
        // Extraer y guardar el token si est√° disponible
        if (data.url) {
          const extractedToken = extractTokenFromUrl(data.url);
          if (extractedToken) {
            cacheToken("ESPN5", extractedToken);
          }
        }
        
        console.log('Using URL for ESPN5:', data.url);
        return data.url;
      } catch (e) {
        console.warn('Proxy espn5 failed', e);
      }    } else if (lower.includes('espn6') || lower.includes('espn 6')) {
      if (KNOWN_TOKENS["ESPN6"]) {
        const espn6Token = KNOWN_TOKENS["ESPN6"];
        // Guardar token en cach√©
        cacheToken("ESPN6", espn6Token);
        return `https://agvyby.fubohd.com/espn6/mono.m3u8?token=${espn6Token}`;
      }
      try {
        const res = await fetch(`${API_BASE_URL}/api/stream/espn6`);
        const data = await res.json();
        
        // Extraer y guardar el token si est√° disponible
        if (data.url) {
          const extractedToken = extractTokenFromUrl(data.url);
          if (extractedToken) {
            cacheToken("ESPN6", extractedToken);
          }
        }
        
        console.log('Using URL for ESPN6:', data.url);
        return data.url;
      } catch (e) {
        console.warn('Proxy espn6 failed', e);
      }    } else if (lower.includes('espn7') || lower.includes('espn 7')) {
      if (KNOWN_TOKENS["ESPN7"]) {
        const espn7Token = KNOWN_TOKENS["ESPN7"];
        // Guardar token en cach√©
        cacheToken("ESPN7", espn7Token);
        return `https://c2f2zq.fubohd.com/espn7/mono.m3u8?token=${espn7Token}`;
      }
      try {
        const res = await fetch(`${API_BASE_URL}/api/stream/espn7`);
        const data = await res.json();
        
        // Extraer y guardar el token si est√° disponible
        if (data.url) {
          const extractedToken = extractTokenFromUrl(data.url);
          if (extractedToken) {
            cacheToken("ESPN7", extractedToken);
          }
        }
        
        console.log('Using URL for ESPN7:', data.url);
        return data.url;
      } catch (e) {
        console.warn('Proxy espn7 failed', e);
      }    } else if (lower.includes('espn3') || lower.includes('espn 3')) {
      if (KNOWN_TOKENS["ESPN3"]) {
        const espn3Token = KNOWN_TOKENS["ESPN3"];
        // Guardar token en cach√©
        cacheToken("ESPN3", espn3Token);
        return `https://am91cm5leQ.fubohd.com/espn3/mono.m3u8?token=${espn3Token}`;
      }
      try {
        const res = await fetch(`${API_BASE_URL}/api/stream/espn3`);
        const data = await res.json();
        
        // Extraer y guardar el token si est√° disponible
        if (data.url) {
          const extractedToken = extractTokenFromUrl(data.url);
          if (extractedToken) {
            cacheToken("ESPN3", extractedToken);
          }
        }
        
        console.log('Using URL for ESPN3:', data.url);
        return data.url;
      } catch (e) {
        console.warn('Proxy espn3 failed', e);
      }    } else if (lower.includes('espn2') || lower.includes('espn 2')) {
      if (KNOWN_TOKENS["ESPN2"]) {
        const espn2Token = KNOWN_TOKENS["ESPN2"];
        // Guardar token en cach√©
        cacheToken("ESPN2", espn2Token);
        return `https://bGFuZQ.fubohd.com/espn2/mono.m3u8?token=${espn2Token}`;
      }
      try {
        const res = await fetch(`${API_BASE_URL}/api/stream/espn2`);
        const data = await res.json();
        
        // Extraer y guardar el token si est√° disponible
        if (data.url) {
          const extractedToken = extractTokenFromUrl(data.url);
          if (extractedToken) {
            cacheToken("ESPN2", extractedToken);
          }
        }
        
        console.log('Using URL for ESPN2:', data.url);
        return data.url;
      } catch (e) {
        console.warn('Proxy espn2 failed', e);
      }    } else if (lower.includes('espn') && 
        !lower.includes('espn2') && !lower.includes('espn 2') && 
        !lower.includes('espn3') && !lower.includes('espn 3') && 
        !lower.includes('espn4') && !lower.includes('espn 4') &&
        !lower.includes('espn5') && !lower.includes('espn 5') &&
        !lower.includes('espn6') && !lower.includes('espn 6') &&
        !lower.includes('espn7') && !lower.includes('espn 7')) {
      if (KNOWN_TOKENS["ESPN"]) {
        const espnToken = KNOWN_TOKENS["ESPN"];
        // Guardar token en cach√©
        cacheToken("ESPN", espnToken);
        return `https://c2f2zq.fubohd.com/espn/mono.m3u8?token=${espnToken}`;
      }
      try {
        const res = await fetch(`${API_BASE_URL}/api/stream/espn`);
        const data = await res.json();
        
        // Extraer y guardar el token si est√° disponible
        if (data.url) {
          const extractedToken = extractTokenFromUrl(data.url);
          if (extractedToken) {
            cacheToken("ESPN", extractedToken);
          }
        }
        
        console.log('Using URL for ESPN:', data.url);
        return data.url;
        return data.url;
      } catch (e) {
        console.warn('Proxy espn failed', e);
      }    } else if (lower.includes('directv sports') && !lower.includes('plus')) {
      if (KNOWN_TOKENS["DIRECTV Sports HD"]) {
        const dsportsToken = KNOWN_TOKENS["DIRECTV Sports HD"];
        // Guardar token en cach√©
        cacheToken("DIRECTV Sports HD", dsportsToken);
        return `https://tyg2mnl9.fubohd.com/dsports/mono.m3u8?token=${dsportsToken}`;
      }
      try {
        // Extraer y guardar el token si est√° disponibleeam/dsports`);
        if (data.url) {ait res.json();
          const extractedToken = extractTokenFromUrl(data.url);
          if (extractedToken) { token si est√° disponible
            cacheToken("DIRECTV Sports HD", extractedToken);
          }onst extractedToken = extractTokenFromUrl(data.url);
        } if (extractedToken) {
            cacheToken("DIRECTV Sports HD", extractedToken);
        console.log('Using URL for DirecTV Sports:', data.url);
        return data.url;
      } catch (e) {
        console.warn('Proxy dsports failed', e);s:', data.url);
      } return data.url;
  } else if (lower.includes('gol peru') || lower.includes('golperu') || lower.includes('gol per√∫')) {
    // Verificar si tenemos token en cach√©', e);
    const cachedToken = getValidCachedToken("Gol Per√∫");
    if (cachedToken && CHANNEL_BASE_URLS["Gol Per√∫"]) {es('golperu') || lower.includes('gol per√∫')) {
      console.log(`Usando token en cach√© para Gol Per√∫: ${cachedToken.substring(0, 10)}...`);
      return `${CHANNEL_BASE_URLS["Gol Per√∫"]}?token=${cachedToken}`;
    }f (cachedToken && CHANNEL_BASE_URLS["Gol Per√∫"]) {
      console.log(`Usando token en cach√© para Gol Per√∫: ${cachedToken.substring(0, 10)}...`);
    try {urn `${CHANNEL_BASE_URLS["Gol Per√∫"]}?token=${cachedToken}`;
      const res = await fetch(`${API_BASE_URL}/api/stream/golperu`);
      const data = await res.json();
      y {
      // Extraer y guardar el token si est√° disponibleeam/golperu`);
      if (data.url) {ait res.json();
        const extractedToken = extractTokenFromUrl(data.url);
        if (extractedToken) { token si est√° disponible
          cacheToken("Gol Per√∫", extractedToken);
        }onst extractedToken = extractTokenFromUrl(data.url);
      } if (extractedToken) {
          cacheToken("Gol Per√∫", extractedToken);
      return data.url;
    } catch (e) {
      console.warn('Proxy golperu failed', e);
    }    } else if (lower.includes('liga 1 max')) {
      if (KNOWN_TOKENS["Liga 1 Max"]) {
        const liga1Token = KNOWN_TOKENS["Liga 1 Max"];
        // Guardar token en cach√©s('liga 1 max')) {
        cacheToken("Liga 1 Max", liga1Token);
        return `https://dglvz29s.fubohd.com/liga1max/mono.m3u8?token=${liga1Token}`;
      } // Guardar token en cach√©
      try {heToken("Liga 1 Max", liga1Token);
        const res = await fetch(`${API_BASE_URL}/api/stream/liga1max`);liga1Token}`;
        const data = await res.json();
        y {
        // Extraer y guardar el token si est√° disponibleeam/liga1max`);
        if (data.url) {ait res.json();
          const extractedToken = extractTokenFromUrl(data.url);
          if (extractedToken) { token si est√° disponible
            cacheToken("Liga 1 Max", extractedToken);
          }onst extractedToken = extractTokenFromUrl(data.url);
        } if (extractedToken) {
            cacheToken("Liga 1 Max", extractedToken);
        return data.url;
      } catch (e) {
        console.warn('Proxy liga1max failed', e);
      } return data.url;
  } else if (lower.includes('movistar')) {
    // Verificar si tenemos token en cach√©d', e);
    const cachedToken = getValidCachedToken("Movistar Deportes");
    if (cachedToken && CHANNEL_BASE_URLS["Movistar Deportes"]) {
      console.log(`Usando token en cach√© para Movistar Deportes: ${cachedToken.substring(0, 10)}...`);
      return `${CHANNEL_BASE_URLS["Movistar Deportes"]}?token=${cachedToken}`;
    }f (cachedToken && CHANNEL_BASE_URLS["Movistar Deportes"]) {
      console.log(`Usando token en cach√© para Movistar Deportes: ${cachedToken.substring(0, 10)}...`);
    try {urn `${CHANNEL_BASE_URLS["Movistar Deportes"]}?token=${cachedToken}`;
      const res = await fetch(`${API_BASE_URL}/api/stream/movistar`);
      const data = await res.json();
      y {
      // Extraer y guardar el token si est√° disponibleeam/movistar`);
      if (data.url) {ait res.json();
        const extractedToken = extractTokenFromUrl(data.url);
        if (extractedToken) { token si est√° disponible
          cacheToken("Movistar Deportes", extractedToken);
        }onst extractedToken = extractTokenFromUrl(data.url);
      } if (extractedToken) {
          cacheToken("Movistar Deportes", extractedToken);
      console.log('Using URL for Movistar:', data.url);
      return data.url;
    } catch (e) {
      console.warn('Proxy movistar failed', e);ta.url);
    } return data.url;
  } else if (lower.includes('directv plus')) {
    if (KNOWN_TOKENS["DirecTV Plus"]) {ed', e);
      const dsportsPlusToken = KNOWN_TOKENS["DirecTV Plus"];
      // Guardar token en cach√©rectv plus')) {
      cacheToken("DirecTV Plus", dsportsPlusToken);
      return `https://b2ZmaWNpYWw.fubohd.com/dsportsplus/mono.m3u8?token=${dsportsPlusToken}`;
    } // Guardar token en cach√©
    try {heToken("DirecTV Plus", dsportsPlusToken);
      const res = await fetch(`${API_BASE_URL}/api/stream/dsportsplus`);=${dsportsPlusToken}`;
      const data = await res.json();
      y {
      // Extraer y guardar el token si est√° disponibleeam/dsportsplus`);
      if (data.url) {ait res.json();
        const extractedToken = extractTokenFromUrl(data.url);
        if (extractedToken) { token si est√° disponible
          cacheToken("DirecTV Plus", extractedToken);
        }onst extractedToken = extractTokenFromUrl(data.url);
      } if (extractedToken) {
          cacheToken("DirecTV Plus", extractedToken);
      console.log('Using URL for DirecTV Plus:', data.url);
      return data.url;
    } catch (e) {
      console.warn('Proxy dsportsplus failed', e);ata.url);
    } return data.url;
  } } catch (e) {
  try {onsole.warn('Proxy dsportsplus failed', e);
    const channels = await fetchCatalog('https://iptv-org.github.io/api/channels.json', 'channels');
    const ch = channels.find(c => (c.name || '').toLowerCase().includes(channelName.toLowerCase()));
    if (!ch) return null;
    const streams = await fetchCatalog('https://iptv-org.github.io/api/streams.json', 'streams');');
    const match = streams.find(s => s.channel === ch.id && s.url && s.url.endsWith('.m3u8'));se()));
    return match ? match.url : null;
  } catch (e) {ms = await fetchCatalog('https://iptv-org.github.io/api/streams.json', 'streams');
    console.error('fetchNewLink error', e);el === ch.id && s.url && s.url.endsWith('.m3u8'));
    return null; ? match.url : null;
  } catch (e) {
}   console.error('fetchNewLink error', e);
    return null;
//--------------------------------------
// UI helpers
//--------------------------------------
function showStatus(msg) {--------------
  let statusEl = document.getElementById('status-msg');
  if (!statusEl) {----------------------
    statusEl = document.createElement('div');
    statusEl.id = 'status-msg';ementById('status-msg');
    statusEl.className = 'status';
    statusEl.style.padding = '10px';t('div');
    statusEl.style.margin = '10px 0';
    statusEl.style.backgroundColor = 'rgba(0,0,0,0.7)';
    statusEl.style.color = 'white';;
    statusEl.style.borderRadius = '4px';
    statusEl.style.textAlign = 'center';ba(0,0,0,0.7)';
    const playerContainer = document.querySelector('.video-player');
    playerContainer.appendChild(statusEl);
  } statusEl.style.textAlign = 'center';
  console.log(`Status: ${msg}`); // Log en consola para depuraci√≥n);
  statusEl.textContent = msg;ld(statusEl);
} }
  console.log(`Status: ${msg}`); // Log en consola para depuraci√≥n
//--------------------------------------
// Reproductor
//--------------------------------------
let currentChannel = null;--------------
let sourceIndex = 0;
let hls = null;-------------------------
const video = document.getElementById('player');
let sourceIndex = 0;
// Reproductor DASH
let dashPlayer = null;.getElementById('player');

// Funci√≥n para limpiar el reproductor DASH
function cleanupDashPlayer() {
  if (dashPlayer) {
    try {n para limpiar el reproductor DASH
      dashPlayer.destroy();) {
      dashPlayer = null;
      console.log('Reproductor DASH limpiado correctamente');
    } catch (error) {roy();
      console.error('Error al limpiar el reproductor DASH:', error);
    } console.log('Reproductor DASH limpiado correctamente');
  } } catch (error) {
}     console.error('Error al limpiar el reproductor DASH:', error);
    }
// Funci√≥n para configurar el reproductor DASH
function setupDashPlayer(url) {
  try {
    const video = document.getElementById('player');
    tion setupDashPlayer(url) {
    // Verificar si la biblioteca DASH.js est√° cargada
    if (typeof dashjs === 'undefined') {d('player');
      console.error('Error: DASH.js no est√° cargado. No se puede reproducir este contenido.');
      showStatus('‚ùå Error: No se puede reproducir este contenido DASH. Biblioteca DASH.js no est√° cargada.');
      return;f dashjs === 'undefined') {
    } console.error('Error: DASH.js no est√° cargado. No se puede reproducir este contenido.');
      showStatus('‚ùå Error: No se puede reproducir este contenido DASH. Biblioteca DASH.js no est√° cargada.');
    // Limpiamos cualquier instancia previa de Dash.js
    cleanupDashPlayer();
    
    // Inicializamos el reproductor DASHvia de Dash.js
    dashPlayer = dashjs.MediaPlayer().create();
    dashPlayer.initialize(video, url, true);
    dashPlayer.updateSettings({ctor DASH
      'streaming': {hjs.MediaPlayer().create();
        'lowLatencyEnabled': false,l, true);
        'abr': {pdateSettings({
          'autoSwitchBitrate': {
            'video': trued': false,
          }r': {
        },'autoSwitchBitrate': {
        'buffer': {: true
          'stableBufferTime': 20,
          'bufferTimeAtTopQuality': 10,
          'bufferTimeAtTopQualityLongForm': 10
        } 'stableBufferTime': 20,
      }   'bufferTimeAtTopQuality': 10,
    });   'bufferTimeAtTopQualityLongForm': 10
        }
    // Manejadores de eventos
    dashPlayer.on(dashjs.MediaPlayer.events.ERROR, function(e) {
      console.error('Error en DASH player:', e);
      if (e.error === 'download' || e.error === 'manifestError') {
        showStatus(`‚ùå Error al cargar el stream: ${currentChannel}. El enlace podr√≠a haber expirado o estar protegido.`);
        handleStreamError(true);SH player:', e);
      }f (e.error === 'download' || e.error === 'manifestError') {
    }); showStatus(`‚ùå Error al cargar el stream: ${currentChannel}. El enlace podr√≠a haber expirado o estar protegido.`);
        handleStreamError(true);
    dashPlayer.on(dashjs.MediaPlayer.events.QUALITY_CHANGE_RENDERED, function(e) {
      const qBadge = document.getElementById('quality-badge');
      if (qBadge && dashPlayer.getBitrateInfoListFor("video") && dashPlayer.getBitrateInfoListFor("video")[e.newQuality]) {
        const height = dashPlayer.getBitrateInfoListFor("video")[e.newQuality].height || '';
        qBadge.textContent = height ? height + 'p' : '';dge');
      }f (qBadge && dashPlayer.getBitrateInfoListFor("video") && dashPlayer.getBitrateInfoListFor("video")[e.newQuality]) {
    }); const height = dashPlayer.getBitrateInfoListFor("video")[e.newQuality].height || '';
        qBadge.textContent = height ? height + 'p' : '';
    showStatus(`Reproduciendo ${currentChannel}`);
    });
    // Intentamos reproducir con manejo de errores para la pol√≠tica de autoplay
    const playPromise = video.play();ntChannel}`);
    if (playPromise !== undefined) {
      playPromise.catch(error => {anejo de errores para la pol√≠tica de autoplay
        console.log('Autoplay prevenido:', error);
        showStatus('Haz clic en PLAY ‚ñ∂Ô∏è para comenzar a ver el canal');
        addPlayButton();error => {
      });onsole.log('Autoplay prevenido:', error);
    }   showStatus('Haz clic en PLAY ‚ñ∂Ô∏è para comenzar a ver el canal');
        addPlayButton();
  } catch (error) {
    console.error('Error al configurar el reproductor DASH:', error);
    showStatus('‚ùå Error al configurar el reproductor DASH. Intenta con otro canal.');
  } catch (error) {
}   console.error('Error al configurar el reproductor DASH:', error);
    showStatus('‚ùå Error al configurar el reproductor DASH. Intenta con otro canal.');
// Funci√≥n para inicializar el reproductor DASH
function initDashPlayer(url) {
  // Verificar si la biblioteca DASH.js est√° disponible
  if (typeof dashjs === 'undefined') {ctor DASH
    console.log('La biblioteca DASH.js no est√° cargada. Cargando desde CDN...');
    const script = document.createElement('script');ble
    script.src = 'https://cdn.dashjs.org/latest/dash.all.min.js';
    script.onload = () => {eca DASH.js no est√° cargada. Cargando desde CDN...');
      console.log('Biblioteca DASH.js cargada correctamente');
      setupDashPlayer(url);dn.dashjs.org/latest/dash.all.min.js';
    };ript.onload = () => {
    script.onerror = () => {a DASH.js cargada correctamente');
      console.error('Error al cargar DASH.js');
      showStatus('‚ùå No se pudo cargar la biblioteca DASH.js para reproducir este canal.');
    };ript.onerror = () => {
    document.head.appendChild(script);ASH.js');
  } else {Status('‚ùå No se pudo cargar la biblioteca DASH.js para reproducir este canal.');
    setupDashPlayer(url);
  } document.head.appendChild(script);
} } else {
    setupDashPlayer(url);
// Funci√≥n para cargar un canal seleccionado
function loadChannel(name, directUrl = null) {
  console.log(`Cargando canal: ${name} ${directUrl ? '(URL directa)' : ''}`);
   Funci√≥n para cargar un canal seleccionado
  // Establecer canal actualirectUrl = null) {
  currentChannel = name;canal: ${name} ${directUrl ? '(URL directa)' : ''}`);
  sourceIndex = 0;
  // Establecer canal actual
  // Ocultar mensajes anteriores
  const elements = document.querySelectorAll('.status, #welcome-msg, #try-demo-msg, #blocked-stream-msg, #fubo-token-msg');
  elements.forEach(el => {
    if (el) el.style.display = 'none';
  });st elements = document.querySelectorAll('.status, #welcome-msg, #try-demo-msg, #blocked-stream-msg, #fubo-token-msg');
  elements.forEach(el => {
  // Mostrar logo y t√≠tuloay = 'none';
  const logo = document.getElementById('channel-logo');
  if (logo) {
    logo.src = LOGOS[name] || '';
    logo.style.display = LOGOS[name] ? 'block' : 'none';
  }f (logo) {
    logo.src = LOGOS[name] || '';
  const title = document.getElementById('channel-title');
  if (title) {
    title.textContent = name;
  }onst title = document.getElementById('channel-title');
  if (title) {
  showStatus(`Cargando ${name}...`);
  }
  // Si es un canal de demostraci√≥n, usar la URL directamente
  if (DEMO_STREAMS[name]) {me}...`);
    console.log(`Usando URL de demostraci√≥n para ${name}`);
    attachStream(DEMO_STREAMS[name]);usar la URL directamente
    return;STREAMS[name]) {
  } console.log(`Usando URL de demostraci√≥n para ${name}`);
    attachStream(DEMO_STREAMS[name]);
  // Si se proporcion√≥ una URL directa, usarla
  if (directUrl) {
    console.log(`Usando URL directa para ${name}`);
    attachStream(directUrl);RL directa, usarla
    return;tUrl) {
  } console.log(`Usando URL directa para ${name}`);
    attachStream(directUrl);
  // Si el canal no est√° definido, mostrar mensaje
  if (!CHANNELS[name] || CHANNELS[name].length === 0) {
    console.warn(`Canal no encontrado: ${name}`);
    showStatus(`‚ùå Canal no encontrado: ${name}`);e
    showTryDemoChannelsMessage();[name].length === 0) {
    return;.warn(`Canal no encontrado: ${name}`);
  } showStatus(`‚ùå Canal no encontrado: ${name}`);
    showTryDemoChannelsMessage();
  // Intentar cargar el canal desde la lista de fuentes
  console.log(`Intentando cargar ${name} desde la fuente #${sourceIndex+1}`);
  attachStream(CHANNELS[name][sourceIndex]);
} // Intentar cargar el canal desde la lista de fuentes
  console.log(`Intentando cargar ${name} desde la fuente #${sourceIndex+1}`);
// Hacer que la funci√≥n loadChannel est√© disponible globalmente
window.loadChannel = loadChannel;

// Funciones auxiliares para reproducci√≥ndisponible globalmente
function extractStreamToken(url) {
  if (!url) return null;
   Funciones auxiliares para reproducci√≥n
  // Extraer token en varios formatos
  if (url.includes('token=')) {
    const tokenMatch = url.match(/token=([^&]+)/);
    return tokenMatch ? tokenMatch[1] : null;
  } else if (url.includes('hdnts=')) {
    const tokenMatch = url.match(/hdnts=([^&]+)/);
    return tokenMatch ? tokenMatch[1] : null;
  } else if (url.includes('auth=')) {{
    const tokenMatch = url.match(/auth=([^&]+)/);;
    return tokenMatch ? tokenMatch[1] : null;
  } else if (url.includes('auth=')) {
    const tokenMatch = url.match(/auth=([^&]+)/);
  return null; // Retorna null si no se encuentra ning√∫n token
  }
  return null;
} return null; // Retorna null si no se encuentra ning√∫n token
  
function isTokenProbablyExpired(token) {
  // Tokens de 32 caracteres o m√°s suelen incluir timestamps
  if (!token || token.length < 32) return false;
  nction isTokenProbablyExpired(token) {
  // Tokens con fechas unix (10 d√≠gitos) suelen expirartamps
  const hasUnixTimestamp = /\d{10}/.test(token);
  
  // Si es un token largo (m√°s de 40 caracteres) y contiene n√∫meros, es probable que est√© basado en tiempo
  return (token.length > 40 && /\d+/.test(token)) || hasUnixTimestamp;
} 
  // Si es un token largo (m√°s de 40 caracteres) y contiene n√∫meros, es probable que est√© basado en tiempo
function tryCorsBypassProxy(url) {+/.test(token)) || hasUnixTimestamp;
  // Intentar con diversos servicios de proxy CORS
  if (!url) return url;
  nction tryCorsBypassProxy(url) {
  // Solo aplicar a URLs espec√≠ficas que sabemos que pueden tener problemas
  if (url.includes('akamaized.net') || url.includes('mux.dev')) {
    return `https://cors.consumet.stream/${url}`;

  }/ Solo aplicar a URLs espec√≠ficas que sabemos que pueden tener problemas
  return url;ludes('akamaized.net') || url.includes('mux.dev')) {
}   return `https://cors.consumet.stream/${url}`;
  }
function needsProxyAccess(url) {
  // Dominios conocidos que suelen requerir proxy por bloqueos CORS o restricciones
  const restrictedDomains = [
    'akamaized.net', cess(url) {
    'fubo', s conocidos que suelen requerir proxy por bloqueos CORS o restricciones
    'espn',trictedDomains = [
    'mux.dev', .net', 
    'directv',
    'dsports'
  ];'mux.dev',
    'directv',
  return restrictedDomains.some(domain => url.toLowerCase().includes(domain));
} ];
  
function checkHlsSupport() {ome(domain => url.toLowerCase().includes(domain));
  const result = {
    hlsJs: typeof Hls !== 'undefined' && Hls.isSupported(),
    native: falseSupport() {
  };nst result = {
    hlsJs: typeof Hls !== 'undefined' && Hls.isSupported(),
  const videoTest = document.createElement('video');
  if (videoTest.canPlayType('application/vnd.apple.mpegurl') || 
      videoTest.canPlayType('application/x-mpegURL')) {
    result.native = true;ent.createElement('video');
  }f (videoTest.canPlayType('application/vnd.apple.mpegurl') || 
      videoTest.canPlayType('application/x-mpegURL')) {
  return result;e = true;
} }
  
// Funci√≥n para cargar un stream a trav√©s del proxy del servidor
// Esta funci√≥n maneja las peticiones al backend para obtener streams, especialmente para dispositivos m√≥viles
// Funci√≥n para cargar stream a trav√©s del proxy
function loadStreamViaProxy(proxyUrl, originalToken = null) {
  console.log(`Intentando cargar stream v√≠a proxy: ${proxyUrl}`);
  showStatus('Conectando a trav√©s del servidor proxy...');
  
  fetch(proxyUrl)
    .then(response => {
      if (!response.ok) {
        if (response.status === 403) {
          throw new Error('Acceso denegado (403) - El token puede haber expirado');
        }
        throw new Error(`Error en la respuesta del servidor: ${response.status}`);
      }
      return response.json();
    })
    .then(data => {
      if (!data.url) {
        throw new Error('El servidor no devolvi√≥ una URL v√°lida');
      }
      
      console.log('URL de stream obtenida v√≠a proxy:', data.url.substring(0, 50) + '...');
      
      // Si hemos recibido un token nuevo, lo guardamos
      if (data.token && originalToken !== data.token) {
        console.log('Nuevo token recibido, guardando...');
        const channelKey = currentChannel.replace(/\s+/g, '').toLowerCase();
        cacheToken(channelKey, data.token, true); // true indica que es un token m√≥vil
      }
      
      // Verificar si es un stream MPD (DASH)
      if (data.url.includes('.mpd')) {
        console.log('Detectado stream DASH, intentando reproducir con dash.js');
        initDashPlayer(data.url);
        return;
      }
      
      // Intentar reproducir el stream con HLS.js o el reproductor nativo
      if (Hls.isSupported()) {
        console.log('Reproduciendo con HLS.js');
        if (hls) {
          hls.destroy();
        }
        
        hls = new Hls({
          xhrSetup: xhr => {
            xhr.withCredentials = false; // Para evitar problemas de CORS
          }
        });
        
        const video = document.getElementById('player');
        hls.loadSource(data.url);
        hls.attachMedia(video);
        
        hls.on(Hls.Events.MANIFEST_PARSED, () => {
          // Intenta reproducir con manejo de errores para la pol√≠tica de autoplay
          const playPromise = video.play();
          s.on(Hls.Events.MANIFEST_PARSED, () => {
          if (playPromise !== undefined) { de errores para la pol√≠tica de autoplay
            playPromise.then(() => {play();
              showStatus(`Reproduciendo ${currentChannel}`);
            }).catch(error => {ndefined) {
              console.log('Autoplay prevented:', error);
              showStatus('Haz clic en PLAY ‚ñ∂Ô∏è para comenzar a ver el canal');
              addPlayButton();{
            });onsole.log('Autoplay prevenido:', error);
          }   showStatus('Haz clic en PLAY ‚ñ∂Ô∏è para comenzar a ver el canal');
        });   addPlayButton();
            });
        hls.on(Hls.Events.ERROR, (event, data) => {
          if (data.fatal) {
            console.error('Error fatal en HLS:', data);
            switch(data.type) {, (event, data) => {
              case Hls.ErrorTypes.NETWORK_ERROR:
                showStatus('‚ùå Error de red al cargar el stream');
                if (data.response && data.response.code === 403) {
                  showBlockedStreamMessage(currentChannel);
                } else {us('‚ùå Error de red al cargar el stream');
                  tryNextSource();&& data.response.code === 403) {
                } showBlockedStreamMessage(currentChannel);
                break; {
              case Hls.ErrorTypes.MEDIA_ERROR:
                showStatus('Intentando recuperar de error de medios...');
                hls.recoverMediaError();
                break;.ErrorTypes.MEDIA_ERROR:
              default:atus('Intentando recuperar de error de medios...');
                showStatus('‚ùå Error al cargar el stream, intentando otra fuente...');
                break;
              default:
                showStatus('‚ùå Error al cargar el stream, intentando otra fuente...');
                tryNextSource();
                break;
            }
          }
        });
      } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
        // Navegadores iOS y Safari admiten HLS de forma nativa
        console.log('Reproduciendo con soporte nativo de HLS');
        const video = document.getElementById('player');
        video.src = data.url;
        video.addEventListener('loadedmetadata', () => {
          video.play().catch(err => {
            console.log('Autoplay prevenido en modo proxy (Safari):', err);
            showStatus('Haz clic en PLAY ‚ñ∂Ô∏è para comenzar a ver');
            addPlayButton();
          });
        });
      } else {
        console.error('Este navegador no soporta HLS');
        showStatus('‚ùå Este navegador no es compatible con el formato del stream');
      }
    })
    .catch(error => {
      console.error('Error en loadStreamViaProxy:', error);
      showStatus(`‚ùå Error al conectar con el servidor proxy: ${error.message}`);
      tryNextSource();
    });
}

// Funci√≥n para intentar la siguiente fuente disponible para un canal
function tryNextSource() {
  if (!currentChannel) {
    console.log('No hay canal actual definido para intentar siguiente fuente');
    return;
  }
  
  console.log(`Intentando siguiente fuente para ${currentChannel}`);
  
  // Verificar si hay m√°s fuentes disponibles para este canal
  if (CHANNELS[currentChannel] && sourceIndex < CHANNELS[currentChannel].length - 1) {
    sourceIndex++;
    console.log(`Probando fuente #${sourceIndex+1} de ${CHANNELS[currentChannel].length}`);
    showStatus(`Probando fuente alternativa ${sourceIndex+1}/${CHANNELS[currentChannel].length}...`);
    
    // Cargar la siguiente fuente
    attachStream(CHANNELS[currentChannel][sourceIndex]);
  } else {
    console.log('No hay m√°s fuentes disponibles para este canal');
    showStatus('‚ùå No hay m√°s fuentes disponibles para este canal');
    
    // Mostrar mensaje de error apropiado
    showBlockedStreamMessage(currentChannel);
    
    // Ofrecer opciones alternativas
    showTryAnotherButton();
  }
}

// Funci√≥n para manejar errores de reproducci√≥n
function handleStreamError(isAccessError = false, is403Error = false, isFubohdError = false) {
  // Limpiar reproductor DASH si existe
  cleanupDashPlayer();

  const list = CHANNELS[currentChannel] || [];
  
  // Detectar si es un error 403 basado en la respuesta
  if (is403Error || (currentChannel.toLowerCase().includes('liga 1') && 
                     hls && hls.url && hls.url.includes('fubohd.com'))) {
    console.log(`Error 403 detectado para ${currentChannel}. El proveedor bloquea la reproducci√≥n.`);
    showStatus(`‚õî El proveedor de ${currentChannel} requiere un token actualizado.`);
    
    // Limpiar el token en cach√© para este canal
    if (typeof clearTokenCache === 'function') {
      console.log(`Limpiando token en cach√© para ${currentChannel} debido a error 403`);
      clearTokenCache(currentChannel);
      
      // Mostrar mensaje y bot√≥n para reintentar
      const playerContainer = document.querySelector('.video-player');
      if (playerContainer) {
        const tokenErrorMsg = document.createElement('div');
        tokenErrorMsg.id = 'token-error-msg';
        tokenErrorMsg.className = 'token-error-message';
        
        // Personalizar mensaje seg√∫n el dispositivo
        if (window.isMobileDevice) {
          tokenErrorMsg.innerHTML = `
            <p><strong>Error 403:</strong> El token para ${currentChannel} ha expirado o es inv√°lido.</p>
            <p>Se ha detectado que est√°s usando un dispositivo m√≥vil. En algunos casos, esto puede causar problemas con los tokens.</p>
            <button id="retry-channel-btn" class="action-button">Reintentar</button>
            <button id="force-refresh-btn" class="action-button refresh-button">üîÑ Forzar Actualizaci√≥n Completa</button>
          `;
        } else {
          tokenErrorMsg.innerHTML = `
            <p><strong>Error 403:</strong> El token para ${currentChannel} ha expirado o es inv√°lido.</p>
            <p>Se ha limpiado la cach√© del token. Intente nuevamente.</p>
            <button id="retry-channel-btn" class="action-button">Reintentar</button>
          `;
        }
        
        // Eliminar mensajes existentes
        const existingMsgs = playerContainer.querySelectorAll('#token-error-msg');
        existingMsgs.forEach(el => el.remove());
        
        playerContainer.appendChild(tokenErrorMsg);
        
        // Agregar funci√≥n al bot√≥n de reintentar
        document.getElementById('retry-channel-btn').addEventListener('click', () => {
          tokenErrorMsg.remove();
          loadChannel(currentChannel);
        });
        
        // Agregar funci√≥n al bot√≥n de actualizaci√≥n completa (solo en m√≥vil)
        if (window.isMobileDevice) {
          document.getElementById('force-refresh-btn').addEventListener('click', () => {
            clearAllTokenCache();
            StorageSystem.clear(); // Limpieza completa
            showStatus('Realizando actualizaci√≥n completa...');
            setTimeout(() => {
              window.location.href = window.location.pathname + '?force_refresh=true';
            }, 1000);
          });
        }
      }
    }
    
    showBlockedStreamMessage(currentChannel);
    
    // A√±adir bot√≥n de b√∫squeda en RojaDirecta
    addRojaDirectaSearchButton(currentChannel);
    
    return; // No intentamos m√°s con este canal si hay un bloqueo activo
  }
  
  // Si es un error de acceso espec√≠fico para canales deportivos, intentamos usar el proxy directamente
  if (isAccessError && (
      currentChannel.includes('DIRECTV') || 
      currentChannel.includes('ESPN') || 
      currentChannel.includes('Movistar') || 
      currentChannel.includes('Gol') ||
      currentChannel.includes('Liga 1'))) {
    
    showStatus(`Intentando obtener ${currentChannel} a trav√©s del servidor...`);
    
    // Buscamos una nueva URL espec√≠ficamente a trav√©s de nuestro proxy
    fetchNewLink(currentChannel).then(url => {
      if (url) {
        console.log(`Nueva URL obtenida a trav√©s del proxy para ${currentChannel}`);
        // Agregamos la nueva URL a la lista si no existe
        if (!CHANNELS[currentChannel]) CHANNELS[currentChannel] = [];
        if (!CHANNELS[currentChannel].includes(url)) {
          CHANNELS[currentChannel].push(url);
        }
        sourceIndex = CHANNELS[currentChannel].indexOf(url);
        attachStream(url);
      } else {
        showStatus(`No fue posible obtener una fuente para ${currentChannel}. Los servidores pueden estar bloqueando el acceso o el canal no est√° disponible.`);
        showBlockedStreamMessage(currentChannel);
        
        // A√±adir bot√≥n de b√∫squeda en RojaDirecta como alternativa
        addRojaDirectaSearchButton(currentChannel);
      }
    }).catch(err => {
      console.error('Error al buscar fuente en proxy:', err);
      showStatus(`Error al intentar acceder a ${currentChannel}. Los canales deportivos pueden tener restricciones geogr√°ficas o de IP.`);
      showBlockedStreamMessage(currentChannel);
      
      // A√±adir bot√≥n de b√∫squeda en RojaDirecta como alternativa
      addRojaDirectaSearchButton(currentChannel);
    });
    
    return;
  }
  
  // Si hay fuentes alternativas disponibles
  if (sourceIndex + 1 < list.length) {
    sourceIndex += 1;
    showStatus(`Probando fuente alternativa ${sourceIndex+1}/${list.length}...`);
    console.log(`Cambiando a fuente alternativa ${sourceIndex+1} para ${currentChannel}`);
    attachStream(list[sourceIndex]);
  } else {
    // Si no hay m√°s fuentes en la lista, buscamos nuevas
    showStatus('Buscando nueva fuente...');
    
    // Para los canales de demostraci√≥n, intentamos un proxy CORS como √∫ltimo recurso
    if (DEMO_STREAMS[currentChannel]) {
      const originalUrl = DEMO_STREAMS[currentChannel];
      const proxiedUrl = tryCorsBypassProxy(originalUrl);
      
      if (proxiedUrl !== originalUrl) {
        console.log('Intentando reproducir el canal de demostraci√≥n a trav√©s de proxy CORS');
        showStatus('Intentando reproducir a trav√©s de un proxy alternativo...');
        
        // Agregar la URL con proxy a la lista
        if (!CHANNELS[currentChannel]) CHANNELS[currentChannel] = [];
        CHANNELS[currentChannel].push(proxiedUrl);
        sourceIndex = CHANNELS[currentChannel].length - 1;
        attachStream(proxiedUrl);
        return;
      } else {
        showStatus('Error al reproducir el stream de demostraci√≥n. Puede haber restricciones por regi√≥n o el proveedor ha bloqueado el acceso.');
        showTryAnotherButton();
        return;
      }
    }
    
    // Intentar primero con RojaDirecta para canales deportivos
    if (currentChannel.includes('DIRECTV') || 
        currentChannel.includes('ESPN') || 
        currentChannel.includes('Movistar') || 
        currentChannel.includes('Gol') ||
        currentChannel.includes('Liga 1')) {
      
      showStatus(`Intentando buscar ${currentChannel} en RojaDirecta...`);
      
      getFromRojaDirecta(currentChannel).then(url => {
        if (url) {
          console.log(`Stream encontrado en RojaDirecta para ${currentChannel}`);
          if (!CHANNELS[currentChannel]) CHANNELS[currentChannel] = [];
          CHANNELS[currentChannel].push(url);
          sourceIndex = CHANNELS[currentChannel].length - 1;
          attachStream(url);
          return;
        }
        
        // Si RojaDirecta falla, intentamos con el m√©todo tradicional
        continueWithTraditionalSearch();
      }).catch(err => {
        console.error('Error al buscar en RojaDirecta:', err);
        continueWithTraditionalSearch();
      });
    } else {
      continueWithTraditionalSearch();
    }
    
    function continueWithTraditionalSearch() {
      fetchNewLink(currentChannel).then(url => {
        if (url) {
          console.log(`Nueva URL encontrada para ${currentChannel}: ${url.substring(0, 50)}...`);
          if (!CHANNELS[currentChannel]) CHANNELS[currentChannel] = [];
          CHANNELS[currentChannel].push(url);
          sourceIndex = CHANNELS[currentChannel].length - 1;
          attachStream(url);
        } else {
          showStatus('No se encontr√≥ ninguna fuente disponible. Intenta con otro canal.');
          console.error(`No se pudo encontrar enlace para ${currentChannel}`);
          
          // Mostrar mensaje y bot√≥n para RojaDirecta
          showBlockedStreamMessage(currentChannel);
        }
      }).catch(err => {
        console.error('Error al buscar fuente:', err);
        showStatus(`Error al buscar fuente: ${err.message || 'Error desconocido'}. Intenta con otro canal.`);
        
        // Mostrar mensaje y bot√≥n para RojaDirecta
        showBlockedStreamMessage(currentChannel);
      });
    }
  }
}

// Funci√≥n para obtener streams de RojaDirecta para un canal espec√≠fico
async function getFromRojaDirecta(channelName) {
  try {
    console.log(`Buscando ${channelName} en RojaDirecta...`);
    
    // Realiza una solicitud al endpoint de backend que acabamos de crear
    const res = await fetch(`${API_BASE_URL}/api/rojadirecta/${encodeURIComponent(channelName)}`);
    
    if (!res.ok) {
      console.warn(`RojaDirecta b√∫squeda para ${channelName} fall√≥ con estado ${res.status}`);
      return null;
    }
    
    const data = await res.json();
    
    if (data.success && data.results && data.results.length > 0) {
      console.log(`Encontrados ${data.results.length} streams en RojaDirecta`);
      
      // Obtener la primera URL v√°lida
      const stream = data.results[0];
      
      // Si hay un token en el resultado, guardarlo para futuras referencias
      if (stream.token && stream.url.includes('token=')) {
        console.log(`Token extra√≠do de RojaDirecta para ${channelName}: ${stream.token.substring(0, 15)}...`);
        
        // Opcional: actualizar los tokens conocidos
        // Esta parte es delicada y depende de si quieres mantener los tokens actualizados autom√°ticamente
        /*
        if (channelName in KNOWN_TOKENS) {
          console.log(`Actualizando token para ${channelName} desde RojaDirecta`);
          KNOWN_TOKENS[channelName] = stream.token;
        }
        */
      }
      
      return stream.url;
    }
    
    console.log(`No se encontraron streams en RojaDirecta para ${channelName}`);
    return null;
  } catch (error) {
    console.error(`Error buscando en RojaDirecta: ${error.message}`);
    return null;
  }
}

// Funci√≥n para a√±adir bot√≥n de b√∫squeda en RojaDirecta
function addRojaDirectaSearchButton(channelName) {
  const playerContainer = document.querySelector('.video-player');
  if (!playerContainer) return;
  
  // Eliminar botones existentes
  const existingBtn = document.getElementById('rojadirecta-search-btn');
  if (existingBtn) existingBtn.remove();
  
  const searchBtn = document.createElement('button');
  searchBtn.id = 'rojadirecta-search-btn';
  searchBtn.className = 'action-button rojadirecta-button';
  searchBtn.innerHTML = 'üîé Buscar en RojaDirecta';
  searchBtn.addEventListener('click', async () => {
    // Mostrar indicador de carga
    showStatus(`Buscando ${channelName} en RojaDirecta...`);
    searchBtn.disabled = true;
    searchBtn.textContent = 'Buscando...';
    
    try {
      // Intentar obtener stream de RojaDirecta
      const url = await getFromRojaDirecta(channelName);
      
      if (url) {
        console.log(`Stream encontrado en RojaDirecta: ${url.substring(0, 50)}...`);
        showStatus(`Stream encontrado en RojaDirecta. Reproduciendo...`);
        
        // Agregar la URL a la lista de fuentes del canal
        if (!CHANNELS[channelName]) CHANNELS[channelName] = [];
        CHANNELS[channelName].push(url);
        sourceIndex = CHANNELS[channelName].length - 1;
        
        // Reproducir el stream
        attachStream(url);
      } else {
        console.log(`No se encontr√≥ stream en RojaDirecta para ${channelName}`);
        showStatus(`No se encontr√≥ stream en RojaDirecta para ${channelName}`);
      }
    } catch (error) {
      console.error(`Error buscando en RojaDirecta: ${error.message}`);
      showStatus(`Error buscando en RojaDirecta: ${error.message}`);
    } finally {
      // Restaurar el bot√≥n
      searchBtn.disabled = false;
      searchBtn.innerHTML = 'üîé Buscar en RojaDirecta';
    }
  });
  
  playerContainer.appendChild(searchBtn);
}

// Funci√≥n para limpiar peri√≥dicamente los tokens expirados de la cach√©
function cleanupExpiredTokens() {
  try {
    console.log('Limpiando tokens expirados del cach√©...');
    const now = Date.now();
    let removedCount = 0;
    
    // Recorrer todas las claves en localStorage que correspondan a tokens
    Object.keys(localStorage).forEach(key => {
      if (key.startsWith('token_')) {
        try {
          const data = JSON.parse(localStorage.getItem(key));
          if (data.expiresAt && data.expiresAt < now) {
            localStorage.removeItem(key);
            removedCount++;
            console.log(`Token expirado eliminado: ${data.channel}`);
          }
        } catch (e) {
          // Si hay un error al parsear, eliminar la entrada corrupta
          localStorage.removeItem(key);
          console.warn(`Eliminada entrada corrupta de cach√©: ${key}`);
        }
      }
    });
    
    console.log(`Limpieza completada: ${removedCount} tokens expirados eliminados`);
  } catch (error) {
    console.error('Error al limpiar tokens expirados:', error);
  }
}

// Programar limpieza peri√≥dica (cada 30 minutos)
setInterval(cleanupExpiredTokens, 30 * 60 * 1000);

// Tambi√©n ejecutar al iniciar la aplicaci√≥n
// Crear bot√≥n flotante para limpiar cach√© (especialmente √∫til en dispositivos m√≥viles)
function createFloatingCacheButton() {
  // Solo crear para dispositivos m√≥viles
  if (!window.isMobileDevice) return;
  
  const existingButton = document.getElementById('floating-cache-btn');
  if (existingButton) return;
  
  const floatingButton = document.createElement('button');
  floatingButton.id = 'floating-cache-btn';
  floatingButton.className = 'floating-button refresh-button';
  floatingButton.innerHTML = 'üîÑ';
  floatingButton.title = 'Actualizar Tokens';
  
  // Estilo para el bot√≥n flotante
  floatingButton.style.position = 'fixed';
  floatingButton.style.bottom = '20px';
  floatingButton.style.right = '20px';
  floatingButton.style.zIndex = '1000';
  floatingButton.style.width = '50px';
  floatingButton.style.height = '50px';
  floatingButton.style.borderRadius = '50%';
  floatingButton.style.fontSize = '24px';
  floatingButton.style.backgroundColor = '#2e7d32';
  floatingButton.style.color = 'white';
  floatingButton.style.border = 'none';
  floatingButton.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3)';
  
  // Agregar funcionalidad al bot√≥n
  floatingButton.addEventListener('click', function() {
    this.disabled = true;
    this.textContent = '‚è≥';
    
    // Limpiar todos los tokens y recargar
    clearAllTokenCache();
    StorageSystem.setItem('tokens_version', TOKENS_VERSION.toString());
    StorageSystem.setItem('last_mobile_cleanup', Date.now().toString());
    
    showStatus('Tokens actualizados. Recargando p√°gina...');
    
    // Retrasar la recarga para que el usuario vea el mensaje
    setTimeout(() => {
      window.location.href = window.location.pathname + '?force_refresh=true';
    }, 1000);
  });
  
  document.body.appendChild(floatingButton);
}

document.addEventListener('DOMContentLoaded', () => {
  // Ejecutar limpieza al inicio (despu√©s de 10 segundos para no interferir con la carga)
  setTimeout(cleanupExpiredTokens, 10000);
  
  // Crear bot√≥n flotante para dispositivos m√≥viles
  setTimeout(createFloatingCacheButton, 2000);
  
  console.log('=== SCRIPTS.JS INICIALIZADO ===');
  console.log('Esperando autorizaci√≥n de acceso...');
  
  // Verificar si la biblioteca dash.js est√° disponible
  if (typeof dashjs === 'undefined') {
    console.log('La biblioteca DASH.js no est√° cargada. Cargando desde CDN...');
    const script = document.createElement('script');
    script.src = 'https://cdn.dashjs.org/latest/dash.all.min.js';
    script.onload = () => {
      console.log('Biblioteca DASH.js cargada correctamente');
    };
    script.onerror = () => {
      console.error('Error al cargar DASH.js');
      showStatus('‚ùå No se pudo cargar la biblioteca DASH.js. Los canales que usan DASH podr√≠an no funcionar correctamente.');
    };
    document.head.appendChild(script);
  }
  
  // Verificar que las funciones est√©n en el √°mbito global
  const functionsAvailable = 
    typeof window.setupChannelList === 'function' && 
    typeof window.showWelcomeMessage === 'function' && 
    typeof window.setupSearchFilter === 'function';
  
  console.log('¬øFunciones disponibles globalmente?', functionsAvailable ? 'S√≠ ‚úÖ' : 'No ‚ùå');
  
  if (!functionsAvailable) {
    console.log('Re-exponiendo funciones al √°mbito global...');
    window.setupChannelList = setupChannelList;
    window.showWelcomeMessage = showWelcomeMessage;
    window.setupSearchFilter = setupSearchFilter;
    window.loadChannel = loadChannel;
  }
  
  // Marcar como listo para que auth.js pueda inicializar
  window.scriptsJsReady = true;
  
  // Disparar un evento que auth.js pueda escuchar
  document.dispatchEvent(new CustomEvent('scripts-js-loaded'));
  
  console.log('Scripts.js marcado como listo para inicializaci√≥n desde auth.js');
  console.log('=== FIN INICIALIZACI√ìN SCRIPTS.JS ===');
});

// Dominios conocidos de agregadores de streams deportivos
const STREAM_PROVIDERS = {
  // Fuentes principales
  fubohd: [
    'fubohd.com',
    'fubo.tv',
    'fubo.me'
  ],
  pelotalibre: [
    'pelotalibrehdtv.com',
    'pelotalibre.me',
    'pelotalibre.live',
    'pelotalibre.net',
    'pelotalibre.one',
    'pelotalibre.xyz',
  ],
  rojadirecta: [
    'rojadirecta.watch',
    'rojadirectaenvivo.com',
    'rojadirectatv.tv',
    'rojadirectaenvivo.net',
    'rojadirecta.unblockit.kim'
  ],
  futbolLibre: [
    'futbollibre.net',
    'futbol-libre.net',
    'futbollibrehd.com'
  ],
  tvLibre: [
    'televisionlibre.net',
    'televisionhd.net',
    'tvlibre.me'
  ],
  // Fuentes secundarias
  otros: [
    'tarjetarojatvenvivo.com',
    'apurogol.net',
    'librefutbol.com',
    'televisiongratis.tv',
    'pirlotvhd.com'
  ]
};